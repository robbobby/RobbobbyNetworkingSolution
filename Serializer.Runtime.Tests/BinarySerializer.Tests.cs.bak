using System;
using System.Buffers.Binary;
using System.Text;
using Xunit;
using Serializer.Runtime;

namespace Serializer.Runtime.Tests
{
    [Trait("Category", "Unit")]
    public sealed class RnsCodecTests
    {
        #region Boolean Tests

        [Fact]
        public void WriteBoolean_True_WritesCorrectByte()
        {
            // Arrange
            var buffer = new byte[1];

            // Act
            var bytesWritten = RnsCodec.WriteBoolean(buffer, true);

            // Assert
            Assert.Equal(1, bytesWritten);
            Assert.Equal(1, buffer[0]);
        }

        [Fact]
        public void WriteBoolean_False_WritesCorrectByte()
        {
            // Arrange
            var buffer = new byte[1];

            // Act
            var bytesWritten = RnsCodec.WriteBoolean(buffer, false);

            // Assert
            Assert.Equal(1, bytesWritten);
            Assert.Equal(0, buffer[0]);
        }

        [Fact]
        public void WriteBoolean_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = Array.Empty<byte>();

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteBoolean(buffer, true));
            Assert.Contains("Buffer too small for boolean", exception.Message, StringComparison.Ordinal);
            Assert.Equal("destination", exception.ParamName);
        }

        [Fact]
        public void ReadBoolean_True_ReadsCorrectValue()
        {
            // Arrange
            var buffer = new byte[] { 1 };

            // Act
            var bytesRead = RnsCodec.ReadBoolean(buffer, out var value);

            // Assert
            Assert.Equal(1, bytesRead);
            Assert.True(value);
        }

        [Fact]
        public void ReadBoolean_False_ReadsCorrectValue()
        {
            // Arrange
            var buffer = new byte[] { 0 };

            // Act
            var bytesRead = RnsCodec.ReadBoolean(buffer, out var value);

            // Assert
            Assert.Equal(1, bytesRead);
            Assert.False(value);
        }

        [Fact]
        public void ReadBoolean_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = Array.Empty<byte>();

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.ReadBoolean(buffer, out _));
            Assert.Contains("Buffer too small for boolean", exception.Message, StringComparison.Ordinal);
            Assert.Equal("source", exception.ParamName);
        }

        [Fact]
        public void ReadBooleanStrict_ValidValues_ReadsCorrectly()
        {
            // Arrange
            var buffer = new byte[1];

            // Test true (1)
            buffer[0] = 1;
            var result = RnsCodec.ReadBooleanStrict(buffer, out var value);
            Assert.Equal(1, result);
            Assert.True(value);

            // Test false (0)
            buffer[0] = 0;
            result = RnsCodec.ReadBooleanStrict(buffer, out value);
            Assert.Equal(1, result);
            Assert.False(value);
        }

        [Fact]
        public void ReadBooleanStrict_InvalidValue_ThrowsFormatException()
        {
            // Arrange
            var buffer = new byte[1];
            buffer[0] = 42; // Invalid boolean value

            // Act & Assert
            var exception = Assert.Throws<FormatException>(() => RnsCodec.ReadBooleanStrict(buffer, out _));
            Assert.Contains("Invalid boolean encoding: expected 0 or 1, got 42", exception.Message, StringComparison.Ordinal);
        }

        [Fact]
        public void ReadBooleanStrict_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = Array.Empty<byte>();

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.ReadBooleanStrict(buffer, out _));
            Assert.Contains("Buffer too small for boolean", exception.Message, StringComparison.Ordinal);
            Assert.Equal("source", exception.ParamName);
        }

        #endregion

        #region Byte Tests

        [Fact]
        public void WriteByte_WritesCorrectValue()
        {
            // Arrange
            var buffer = new byte[1];
            var testValue = (byte)0xAB;

            // Act
            var bytesWritten = RnsCodec.WriteByte(buffer, testValue);

            // Assert
            Assert.Equal(1, bytesWritten);
            Assert.Equal(testValue, buffer[0]);
        }

        [Fact]
        public void ReadByte_ReadsCorrectValue()
        {
            // Arrange
            var testValue = (byte)0xCD;
            var buffer = new byte[] { testValue };

            // Act
            var bytesRead = RnsCodec.ReadByte(buffer, out var value);

            // Assert
            Assert.Equal(1, bytesRead);
            Assert.Equal(testValue, value);
        }

        [Fact]
        public void WriteByte_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = Array.Empty<byte>();

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteByte(buffer, 0x12));
            Assert.Contains("Buffer too small for byte", exception.Message, StringComparison.Ordinal);
            Assert.Equal("destination", exception.ParamName);
        }

        [Fact]
        public void ReadByte_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = Array.Empty<byte>();

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.ReadByte(buffer, out _));
            Assert.Contains("Buffer too small for byte", exception.Message, StringComparison.Ordinal);
            Assert.Equal("source", exception.ParamName);
        }

        #endregion

        #region SByte Tests

        [Fact]
        public void WriteSByte_WritesCorrectValue()
        {
            // Arrange
            var buffer = new byte[1];
            var testValue = (sbyte)-42;

            // Act
            var bytesWritten = RnsCodec.WriteSByte(buffer, testValue);

            // Assert
            Assert.Equal(1, bytesWritten);
            Assert.Equal((byte)testValue, buffer[0]);
        }

        [Fact]
        public void ReadSByte_ReadsCorrectValue()
        {
            // Arrange
            var testValue = (sbyte)-123;
            var buffer = new byte[] { (byte)testValue };

            // Act
            var bytesRead = RnsCodec.ReadSByte(buffer, out var value);

            // Assert
            Assert.Equal(1, bytesRead);
            Assert.Equal(testValue, value);
        }

        [Fact]
        public void WriteSByte_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = Array.Empty<byte>();

            // Act & Assert
            var ex = Assert.Throws<ArgumentException>(() => RnsCodec.WriteSByte(buffer, (sbyte)-1));
            Assert.Contains("Buffer too small for sbyte", ex.Message, StringComparison.Ordinal);
            Assert.Equal("destination", ex.ParamName);
        }

        [Fact]
        public void ReadSByte_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = Array.Empty<byte>();

            // Act & Assert
            var ex = Assert.Throws<ArgumentException>(() => RnsCodec.ReadSByte(buffer, out _));
            Assert.Contains("Buffer too small for sbyte", ex.Message, StringComparison.Ordinal);
            Assert.Equal("source", ex.ParamName);
        }

        #endregion

        #region Int16 Tests

        [Theory]
        [InlineData((short)0)]
        [InlineData((short)12345)]
        [InlineData((short)-12345)]
        [InlineData(short.MaxValue)]
        [InlineData(short.MinValue)]
        public void WriteInt16_ReadInt16_RoundTrip(short testValue)
        {
            // Arrange
            var buffer = new byte[2];

            // Act - Write
            var bytesWritten = RnsCodec.WriteInt16(buffer, testValue);
            Assert.Equal(2, bytesWritten);

            // Act - Read
            var bytesRead = RnsCodec.ReadInt16(buffer, out var readValue);

            // Assert
            Assert.Equal(2, bytesRead);
            Assert.Equal(testValue, readValue);
        }

        [Fact]
        public void WriteInt16_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[1];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteInt16(buffer, 12345));
            Assert.Contains("Buffer too small for Int16", exception.Message, StringComparison.Ordinal);
        }

        #endregion

        #region UInt16 Tests

        [Theory]
        [InlineData((ushort)0)]
        [InlineData((ushort)12345)]
        [InlineData((ushort)65535)]
        public void WriteUInt16_ReadUInt16_RoundTrip(ushort testValue)
        {
            // Arrange
            var buffer = new byte[2];

            // Act - Write
            var bytesWritten = RnsCodec.WriteUInt16(buffer, testValue);
            Assert.Equal(2, bytesWritten);

            // Act - Read
            var bytesRead = RnsCodec.ReadUInt16(buffer, out var readValue);

            // Assert
            Assert.Equal(2, bytesRead);
            Assert.Equal(testValue, readValue);
        }

        [Fact]
        public void WriteUInt16_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[1];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteUInt16(buffer, 12345));
            Assert.Contains("Buffer too small for UInt16", exception.Message, StringComparison.Ordinal);
            Assert.Equal("destination", exception.ParamName);
        }

        [Fact]
        public void ReadUInt16_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[1];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.ReadUInt16(buffer, out _));
            Assert.Contains("Buffer too small for UInt16", exception.Message, StringComparison.Ordinal);
            Assert.Equal("source", exception.ParamName);
        }

        #endregion

        #region Int32 Tests

        [Theory]
        [InlineData(0)]
        [InlineData(123456789)]
        [InlineData(-123456789)]
        [InlineData(int.MaxValue)]
        [InlineData(int.MinValue)]
        public void WriteInt32_ReadInt32_RoundTrip(int testValue)
        {
            // Arrange
            var buffer = new byte[4];

            // Act - Write
            var bytesWritten = RnsCodec.WriteInt32(buffer, testValue);
            Assert.Equal(4, bytesWritten);

            // Act - Read
            var bytesRead = RnsCodec.ReadInt32(buffer, out var readValue);

            // Assert
            Assert.Equal(4, bytesRead);
            Assert.Equal(testValue, readValue);
        }

        [Fact]
        public void WriteInt32_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[3];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteInt32(buffer, 123456789));
            Assert.Contains("Buffer too small for Int32", exception.Message, StringComparison.Ordinal);
        }

        #endregion

        #region UInt32 Tests

        [Theory]
        [InlineData(0U)]
        [InlineData(123456789U)]
        [InlineData(uint.MaxValue)]
        public void WriteUInt32_ReadUInt32_RoundTrip(uint testValue)
        {
            // Arrange
            var buffer = new byte[4];

            // Act - Write
            var bytesWritten = RnsCodec.WriteUInt32(buffer, testValue);
            Assert.Equal(4, bytesWritten);

            // Act - Read
            var bytesRead = RnsCodec.ReadUInt32(buffer, out var readValue);

            // Assert
            Assert.Equal(4, bytesRead);
            Assert.Equal(testValue, readValue);
        }

        [Fact]
        public void WriteUInt32_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[3];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteUInt32(buffer, 123456789U));
            Assert.Contains("Buffer too small for UInt32", exception.Message, StringComparison.Ordinal);
            Assert.Equal("destination", exception.ParamName);
        }

        [Fact]
        public void ReadUInt32_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[3];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.ReadUInt32(buffer, out _));
            Assert.Contains("Buffer too small for UInt32", exception.Message, StringComparison.Ordinal);
            Assert.Equal("source", exception.ParamName);
        }

        #endregion

        #region Int64 Tests

        [Theory]
        [InlineData(0L)]
        [InlineData(1234567890123456789L)]
        [InlineData(-1234567890123456789L)]
        [InlineData(long.MaxValue)]
        [InlineData(long.MinValue)]
        public void WriteInt64_ReadInt64_RoundTrip(long testValue)
        {
            // Arrange
            var buffer = new byte[8];

            // Act - Write
            var bytesWritten = RnsCodec.WriteInt64(buffer, testValue);
            Assert.Equal(8, bytesWritten);

            // Act - Read
            var bytesRead = RnsCodec.ReadInt64(buffer, out var readValue);

            // Assert
            Assert.Equal(8, bytesRead);
            Assert.Equal(testValue, readValue);
        }

        [Fact]
        public void WriteInt64_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[7];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteInt64(buffer, 1234567890123456789L));
            Assert.Contains("Buffer too small for Int64", exception.Message, StringComparison.Ordinal);
        }

        #endregion

        #region UInt64 Tests

        [Theory]
        [InlineData(0UL)]
        [InlineData(1234567890123456789UL)]
        [InlineData(ulong.MaxValue)]
        public void WriteUInt64_ReadUInt64_RoundTrip(ulong testValue)
        {
            // Arrange
            var buffer = new byte[8];

            // Act - Write
            var bytesWritten = RnsCodec.WriteUInt64(buffer, testValue);
            Assert.Equal(8, bytesWritten);

            // Act - Read
            var bytesRead = RnsCodec.ReadUInt64(buffer, out var readValue);

            // Assert
            Assert.Equal(8, bytesRead);
            Assert.Equal(testValue, readValue);
        }

        [Fact]
        public void WriteUInt64_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[7];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteUInt64(buffer, 1234567890123456789UL));
            Assert.Contains("Buffer too small for UInt64", exception.Message, StringComparison.Ordinal);
            Assert.Equal("destination", exception.ParamName);
        }

        [Fact]
        public void ReadUInt64_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[7];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.ReadUInt64(buffer, out _));
            Assert.Contains("Buffer too small for UInt64", exception.Message, StringComparison.Ordinal);
            Assert.Equal("source", exception.ParamName);
        }

        #endregion

        #region Single Tests

        [Theory]
        [InlineData(0.0f)]
        [InlineData(3.14159f)]
        [InlineData(-2.71828f)]
        [InlineData(float.MaxValue)]
        [InlineData(float.MinValue)]
        [InlineData(float.Epsilon)]
        public void WriteSingle_ReadSingle_RoundTrip(float testValue)
        {
            // Arrange
            var buffer = new byte[4];

            // Act - Write
            var bytesWritten = RnsCodec.WriteSingle(buffer, testValue);
            Assert.Equal(4, bytesWritten);

            // Act - Read
            var bytesRead = RnsCodec.ReadSingle(buffer, out var readValue);

            // Assert
            Assert.Equal(4, bytesRead);
            Assert.Equal(testValue, readValue);
        }

        [Fact]
        public void WriteSingle_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[3];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteSingle(buffer, 3.14159f));
            Assert.Contains("Buffer too small for Single", exception.Message, StringComparison.Ordinal);
        }

        [Fact]
        public void WriteSingle_ReadSingle_RoundTrip_NaN_And_Infinities()
        {
            var buf = new byte[4];

            // Test NaN
            Assert.Equal(4, RnsCodec.WriteSingle(buf, float.NaN));
            RnsCodec.ReadSingle(buf, out var fNaN);
            Assert.True(float.IsNaN(fNaN));

            // Test Positive Infinity
            Assert.Equal(4, RnsCodec.WriteSingle(buf, float.PositiveInfinity));
            RnsCodec.ReadSingle(buf, out var fPosInf);
            Assert.True(float.IsPositiveInfinity(fPosInf));

            // Test Negative Infinity
            Assert.Equal(4, RnsCodec.WriteSingle(buf, float.NegativeInfinity));
            RnsCodec.ReadSingle(buf, out var fNegInf);
            Assert.True(float.IsNegativeInfinity(fNegInf));
        }

        #endregion

        #region Double Tests

        [Theory]
        [InlineData(0.0)]
        [InlineData(3.141592653589793)]
        [InlineData(-2.718281828459045)]
        [InlineData(double.MaxValue)]
        [InlineData(double.MinValue)]
        [InlineData(double.Epsilon)]
        public void WriteDouble_ReadDouble_RoundTrip(double testValue)
        {
            // Arrange
            var buffer = new byte[8];

            // Act - Write
            var bytesWritten = RnsCodec.WriteDouble(buffer, testValue);
            Assert.Equal(8, bytesWritten);

            // Act - Read
            var bytesRead = RnsCodec.ReadDouble(buffer, out var readValue);

            // Assert
            Assert.Equal(8, bytesRead);
            Assert.Equal(testValue, readValue);
        }

        [Fact]
        public void WriteDouble_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[7];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteDouble(buffer, 3.141592653589793));
            Assert.Contains("Buffer too small for Double", exception.Message, StringComparison.Ordinal);
        }

        [Fact]
        public void WriteDouble_ReadDouble_RoundTrip_NaN_And_Infinities()
        {
            var buf = new byte[8];

            // Test NaN
            Assert.Equal(8, RnsCodec.WriteDouble(buf, double.NaN));
            RnsCodec.ReadDouble(buf, out var dNaN);
            Assert.True(double.IsNaN(dNaN));

            // Test Positive Infinity
            Assert.Equal(8, RnsCodec.WriteDouble(buf, double.PositiveInfinity));
            RnsCodec.ReadDouble(buf, out var dPosInf);
            Assert.True(double.IsPositiveInfinity(dPosInf));

            // Test Negative Infinity
            Assert.Equal(8, RnsCodec.WriteDouble(buf, double.NegativeInfinity));
            RnsCodec.ReadDouble(buf, out var dNegInf);
            Assert.True(double.IsNegativeInfinity(dNegInf));
        }

        #endregion

        #region Guid Tests

        [Fact]
        public void WriteGuid_ReadGuid_RoundTrip()
        {
            // Arrange
            var testGuid = Guid.NewGuid();
            var buffer = new byte[16];

            // Act - Write
            var bytesWritten = RnsCodec.WriteGuid(buffer, testGuid);
            Assert.Equal(16, bytesWritten);

            // Act - Read
            var bytesRead = RnsCodec.ReadGuid(buffer, out var readGuid);

            // Assert
            Assert.Equal(16, bytesRead);
            Assert.Equal(testGuid, readGuid);
        }

        [Fact]
        public void WriteGuid_EmptyGuid_WritesCorrectBytes()
        {
            // Arrange
            var emptyGuid = Guid.Empty;
            var buffer = new byte[16];

            // Act
            var bytesWritten = RnsCodec.WriteGuid(buffer, emptyGuid);

            // Assert
            Assert.Equal(16, bytesWritten);
            // Empty GUID should write 16 zero bytes
            for (int i = 0; i < 16; i++)
            {
                Assert.Equal(0, buffer[i]);
            }
        }

        [Fact]
        public void WriteGuid_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[15];
            var testGuid = Guid.NewGuid();

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteGuid(buffer, testGuid));
            Assert.Contains("Buffer too small for Guid", exception.Message, StringComparison.Ordinal);
        }

        [Fact]
        public void ReadGuid_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[15];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.ReadGuid(buffer, out _));
            Assert.Contains("Buffer too small for Guid", exception.Message, StringComparison.Ordinal);
        }

        [Fact]
        public void WriteGuidRfc4122_ReadGuidRfc4122_RoundTrip()
        {
            // Arrange
            var testGuid = Guid.NewGuid();
            var buffer = new byte[16];

            // Act - Write RFC 4122
            var bytesWritten = RnsCodec.WriteGuidRfc4122(buffer, testGuid);
            Assert.Equal(16, bytesWritten);

            // Act - Read RFC 4122
            var bytesRead = RnsCodec.ReadGuidRfc4122(buffer, out var readGuid);

            // Assert
            Assert.Equal(16, bytesRead);
            Assert.Equal(testGuid, readGuid);
        }

        [Fact]
        public void WriteGuidRfc4122_EmptyGuid_WritesCorrectBytes()
        {
            // Arrange
            var emptyGuid = Guid.Empty;
            var buffer = new byte[16];

            // Act
            var bytesWritten = RnsCodec.WriteGuidRfc4122(buffer, emptyGuid);

            // Assert
            Assert.Equal(16, bytesWritten);
            // Empty GUID should write 16 zero bytes in RFC 4122 order
            for (int i = 0; i < 16; i++)
            {
                Assert.Equal(0, buffer[i]);
            }
        }

        [Fact]
        public void WriteGuidRfc4122_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[15];
            var testGuid = Guid.NewGuid();

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteGuidRfc4122(buffer, testGuid));
            Assert.Contains("Buffer too small for Guid", exception.Message, StringComparison.Ordinal);
        }

        [Fact]
        public void ReadGuidRfc4122_BufferTooSmall_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[15];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.ReadGuidRfc4122(buffer, out _));
            Assert.Contains("Buffer too small for Guid", exception.Message, StringComparison.Ordinal);
        }

        [Fact]
        public void Guid_StandardVsRfc4122_DifferentByteOrder()
        {
            // Arrange
            var testGuid = Guid.NewGuid();
            var standardBuffer = new byte[16];
            var rfc4122Buffer = new byte[16];

            // Act - Write using both methods
            RnsCodec.WriteGuid(standardBuffer, testGuid);
            RnsCodec.WriteGuidRfc4122(rfc4122Buffer, testGuid);

            // Assert - RFC 4122 bytes are the reversals of .NET layout for the first 4/2/2 segments
            var first4 = standardBuffer.AsSpan(0, 4).ToArray();
            Array.Reverse(first4);
            Assert.Equal(first4, rfc4122Buffer.AsSpan(0, 4).ToArray());

            var next2 = standardBuffer.AsSpan(4, 2).ToArray();
            Array.Reverse(next2);
            Assert.Equal(next2, rfc4122Buffer.AsSpan(4, 2).ToArray());

            var next2b = standardBuffer.AsSpan(6, 2).ToArray();
            Array.Reverse(next2b);
            Assert.Equal(next2b, rfc4122Buffer.AsSpan(6, 2).ToArray());

            // Last 8 bytes should be identical
            for (int i = 8; i < 16; i++)
            {
                Assert.Equal(standardBuffer[i], rfc4122Buffer[i]);
            }
        }

        #endregion

        #region Edge Cases and Error Handling

        [Fact]
        public void AllMethods_ReturnCorrectByteCounts()
        {
            // Test that all methods return the expected byte counts
            var buffer = new byte[32];

            Assert.Equal(1, RnsCodec.WriteBoolean(buffer, true));
            Assert.Equal(1, RnsCodec.WriteByte(buffer, 0x42));
            Assert.Equal(1, RnsCodec.WriteSByte(buffer, -42));
            Assert.Equal(2, RnsCodec.WriteInt16(buffer, 12345));
            Assert.Equal(2, RnsCodec.WriteUInt16(buffer, 54321));
            Assert.Equal(4, RnsCodec.WriteInt32(buffer, 123456789));
            Assert.Equal(4, RnsCodec.WriteUInt32(buffer, 987654321));
            Assert.Equal(8, RnsCodec.WriteInt64(buffer, 1234567890123456789L));
            Assert.Equal(8, RnsCodec.WriteUInt64(buffer, 9876543210987654321UL));
            Assert.Equal(4, RnsCodec.WriteSingle(buffer, 3.14159f));
            Assert.Equal(8, RnsCodec.WriteDouble(buffer, 3.141592653589793));
            Assert.Equal(16, RnsCodec.WriteGuid(buffer, Guid.NewGuid()));
            Assert.Equal(16, RnsCodec.WriteGuidRfc4122(buffer, Guid.NewGuid()));
            Assert.Equal(2, RnsCodec.WriteString(buffer, ""));
            Assert.Equal(4, RnsCodec.WriteString(buffer, "Hi"));
        }

        [Fact]
        public void MethodsHandleMinMaxValues()
        {
            var buffer = new byte[32];
            var span = buffer.AsSpan();

            // Test min/max values for each type
            RnsCodec.WriteInt16(span, short.MinValue);
            RnsCodec.WriteInt16(span.Slice(2), short.MaxValue);
            RnsCodec.WriteInt32(span.Slice(4), int.MinValue);
            RnsCodec.WriteInt32(span.Slice(8), int.MaxValue);
            RnsCodec.WriteInt64(span.Slice(12), long.MinValue);
            RnsCodec.WriteInt64(span.Slice(20), long.MaxValue);

            // Read back and verify
            RnsCodec.ReadInt16(span, out var minInt16);
            RnsCodec.ReadInt16(span.Slice(2), out var maxInt16);
            RnsCodec.ReadInt32(span.Slice(4), out var minInt32);
            RnsCodec.ReadInt32(span.Slice(8), out var maxInt32);
            RnsCodec.ReadInt64(span.Slice(12), out var minInt64);
            RnsCodec.ReadInt64(span.Slice(20), out var maxInt64);

            Assert.Equal(short.MinValue, minInt16);
            Assert.Equal(short.MaxValue, maxInt16);
            Assert.Equal(int.MinValue, minInt32);
            Assert.Equal(int.MaxValue, maxInt32);
            Assert.Equal(long.MinValue, minInt64);
            Assert.Equal(long.MaxValue, maxInt64);
        }

        #endregion

        #region String Tests

        [Fact]
        public void WriteString_NullString_WritesLengthZero()
        {
            // Arrange
            var buffer = new byte[2];

            // Act
            var bytesWritten = RnsCodec.WriteString(buffer, null);

            // Assert
            Assert.Equal(2, bytesWritten);
            Assert.Equal(0, BinaryPrimitives.ReadUInt16LittleEndian(buffer));
        }

        [Fact]
        public void WriteString_EmptyString_WritesLengthZero()
        {
            // Arrange
            var buffer = new byte[2];

            // Act
            var bytesWritten = RnsCodec.WriteString(buffer, string.Empty);

            // Assert
            Assert.Equal(2, bytesWritten);
            Assert.Equal(0, BinaryPrimitives.ReadUInt16LittleEndian(buffer));
        }

        [Fact]
        public void WriteString_SimpleAsciiString_WritesCorrectly()
        {
            // Arrange
            var testString = "Hello, World!";
            var buffer = new byte[20];

            // Act
            var bytesWritten = RnsCodec.WriteString(buffer, testString);

            // Assert
            Assert.Equal(2 + testString.Length, bytesWritten);
            Assert.Equal(testString.Length, BinaryPrimitives.ReadUInt16LittleEndian(buffer));
            var writtenString = Encoding.UTF8.GetString(buffer, 2, testString.Length);
            Assert.Equal(testString, writtenString);
        }

        [Fact]
        public void WriteString_UnicodeString_WritesCorrectly()
        {
            // Arrange
            var testString = "Hello, 世界! 🌍";
            var buffer = new byte[50];

            // Act
            var bytesWritten = RnsCodec.WriteString(buffer, testString);

            // Assert
            Assert.Equal(2 + Encoding.UTF8.GetByteCount(testString), bytesWritten);
            var length = BinaryPrimitives.ReadUInt16LittleEndian(buffer);
            Assert.Equal(Encoding.UTF8.GetByteCount(testString), length);
            var writtenString = Encoding.UTF8.GetString(buffer, 2, length);
            Assert.Equal(testString, writtenString);
        }

        [Fact]
        public void WriteString_MaxLengthString_WritesCorrectly()
        {
            // Arrange
            var testString = new string('A', ushort.MaxValue);
            var buffer = new byte[ushort.MaxValue + 2];

            // Act
            var bytesWritten = RnsCodec.WriteString(buffer, testString);

            // Assert
            Assert.Equal(2 + ushort.MaxValue, bytesWritten);
            Assert.Equal(ushort.MaxValue, BinaryPrimitives.ReadUInt16LittleEndian(buffer));
        }

        [Fact]
        public void WriteString_StringTooLong_ThrowsArgumentException()
        {
            // Arrange
            var testString = new string('A', ushort.MaxValue + 1);
            var buffer = new byte[ushort.MaxValue + 3];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteString(buffer, testString));
            Assert.Contains("String too long", exception.Message, StringComparison.Ordinal);
            Assert.Equal("value", exception.ParamName);
        }

        [Fact]
        public void WriteString_BufferTooSmallForLengthPrefix_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[1];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteString(buffer, "test"));
            Assert.Contains("Buffer too small for string", exception.Message, StringComparison.Ordinal);
            Assert.Equal("destination", exception.ParamName);
        }

        [Fact]
        public void WriteString_BufferTooSmallForContent_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[3]; // Only enough for length prefix + 1 byte

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.WriteString(buffer, "test"));
            Assert.Contains("Buffer too small for string", exception.Message, StringComparison.Ordinal);
            Assert.Equal("destination", exception.ParamName);
        }

        [Fact]
        public void ReadString_LengthZero_ReturnsEmptyString()
        {
            // Arrange
            var buffer = new byte[2];
            BinaryPrimitives.WriteUInt16LittleEndian(buffer, 0);

            // Act
            var bytesRead = RnsCodec.ReadString(buffer, out var value);

            // Assert
            Assert.Equal(2, bytesRead);
            Assert.Equal(string.Empty, value);
        }

        [Fact]
        public void ReadString_SimpleAsciiString_ReadsCorrectly()
        {
            // Arrange
            var testString = "Hello, World!";
            var buffer = new byte[20];
            BinaryPrimitives.WriteUInt16LittleEndian(buffer, (ushort)testString.Length);
            Encoding.UTF8.GetBytes(testString).CopyTo(buffer, 2);

            // Act
            var bytesRead = RnsCodec.ReadString(buffer, out var value);

            // Assert
            Assert.Equal(2 + testString.Length, bytesRead);
            Assert.Equal(testString, value);
        }

        [Fact]
        public void ReadString_UnicodeString_ReadsCorrectly()
        {
            // Arrange
            var testString = "Hello, 世界! 🌍";
            var buffer = new byte[50];
            var stringBytes = Encoding.UTF8.GetBytes(testString);
            BinaryPrimitives.WriteUInt16LittleEndian(buffer, (ushort)stringBytes.Length);
            stringBytes.CopyTo(buffer, 2);

            // Act
            var bytesRead = RnsCodec.ReadString(buffer, out var value);

            // Assert
            Assert.Equal(2 + stringBytes.Length, bytesRead);
            Assert.Equal(testString, value);
        }

        [Fact]
        public void ReadString_BufferTooSmallForLengthPrefix_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[1];

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.ReadString(buffer, out _));
            Assert.Contains("Buffer too small for string", exception.Message, StringComparison.Ordinal);
            Assert.Equal("source", exception.ParamName);
        }

        [Fact]
        public void ReadString_BufferTooSmallForContent_ThrowsArgumentException()
        {
            // Arrange
            var buffer = new byte[4]; // Length prefix + 2 bytes
            BinaryPrimitives.WriteUInt16LittleEndian(buffer, 10); // Claim string is 10 bytes

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.ReadString(buffer, out _));
            Assert.Contains("Buffer too small for string", exception.Message, StringComparison.Ordinal);
            Assert.Equal("source", exception.ParamName);
        }

        [Fact]
        public void WriteString_ReadString_RoundTrip()
        {
            // Arrange
            var testString = "Hello, 世界! 🌍";
            var buffer = new byte[100];

            // Act - Write
            var bytesWritten = RnsCodec.WriteString(buffer, testString);

            // Act - Read
            var bytesRead = RnsCodec.ReadString(buffer, out var readString);

            // Assert
            Assert.Equal(bytesWritten, bytesRead);
            Assert.Equal(testString, readString);
        }

        [Fact]
        public void WriteString_ReadString_RoundTrip_Null()
        {
            // Arrange
            var buffer = new byte[2];

            // Act - Write
            var bytesWritten = RnsCodec.WriteString(buffer, null);

            // Act - Read
            var bytesRead = RnsCodec.ReadString(buffer, out var readString);

            // Assert
            Assert.Equal(2, bytesWritten);
            Assert.Equal(2, bytesRead);
            Assert.Equal(string.Empty, readString);
        }

        [Fact]
        public void WriteString_ReadString_RoundTrip_Empty()
        {
            // Arrange
            var buffer = new byte[2];

            // Act - Write
            var bytesWritten = RnsCodec.WriteString(buffer, string.Empty);

            // Act - Read
            var bytesRead = RnsCodec.ReadString(buffer, out var readString);

            // Assert
            Assert.Equal(2, bytesWritten);
            Assert.Equal(2, bytesRead);
            Assert.Equal(string.Empty, readString);
        }

        [Fact]
        public void WriteString_ReadString_RoundTrip_MaxLength()
        {
            // Arrange
            var testString = new string('A', ushort.MaxValue);
            var buffer = new byte[ushort.MaxValue + 2];

            // Act - Write
            var bytesWritten = RnsCodec.WriteString(buffer, testString);

            // Act - Read
            var bytesRead = RnsCodec.ReadString(buffer, out var readString);

            // Assert
            Assert.Equal(2 + ushort.MaxValue, bytesWritten);
            Assert.Equal(2 + ushort.MaxValue, bytesRead);
            Assert.Equal(testString, readString);
        }

        [Fact]
        public void ReadString_InvalidUtf8_ThrowsDecoderFallbackException()
        {
            // Arrange: length=2, bytes 0xC3 0x28 is invalid UTF-8
            var buffer = new byte[] { 0x02, 0x00, 0xC3, 0x28 };

            // Act & Assert
            Assert.Throws<DecoderFallbackException>(() => RnsCodec.ReadString(buffer, out _));
        }

        [Fact]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Security", "CA5394:Do not use insecure randomness", Justification = "Test code only - deterministic seed for reproducible tests")]
        public void WriteString_ReadString_RoundTrip_RandomUnicode()
        {
            var rnd = new Random(12345);
            for (int i = 0; i < 200; i++)
            {
                var s = CreateRandomUnicodeString(rnd, maxChars: 100);
                var buf = new byte[2 + Encoding.UTF8.GetByteCount(s)];
                var written = RnsCodec.WriteString(buf, s);
                var read = RnsCodec.ReadString(buf, out var back);
                Assert.Equal(written, read);
                Assert.Equal(s, back);
            }

            static string CreateRandomUnicodeString(Random r, int maxChars)
            {
                int len = r.Next(0, maxChars + 1);
                var sb = new StringBuilder(len);
                for (int i = 0; i < len; i++)
                {
                    int choice = r.Next(4);
                    int codePoint = choice switch
                    {
                        0 => r.Next(0x20, 0x7F),           // ASCII
                        1 => r.Next(0x80, 0x7FF),          // 2-byte UTF-8
                        2 => r.Next(0x800, 0xD7FF),        // 3-byte, excluding surrogates
                        _ => r.Next(0xE000, 0xFFFF)        // 3-byte BMP non-surrogate
                    };
                    sb.Append((char)codePoint);
                }
                return sb.ToString();
            }
        }

        [Fact]
        public void GetStringSerializedSize_ReturnsCorrectSizes()
        {
            // Test null and empty strings
            Assert.Equal(2, RnsCodec.GetStringSerializedSize(null));
            Assert.Equal(2, RnsCodec.GetStringSerializedSize(string.Empty));

            // Test simple ASCII strings
            Assert.Equal(4, RnsCodec.GetStringSerializedSize("Hi"));
            Assert.Equal(15, RnsCodec.GetStringSerializedSize("Hello, World!"));

            // Test Unicode strings
            var unicodeString = "Hello, 世界! 🌍";
            var expectedSize = 2 + Encoding.UTF8.GetByteCount(unicodeString);
            Assert.Equal(expectedSize, RnsCodec.GetStringSerializedSize(unicodeString));
        }

        [Fact]
        public void GetStringSerializedSize_StringTooLong_ThrowsArgumentException()
        {
            // Arrange
            var testString = new string('A', ushort.MaxValue + 1);

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.GetStringSerializedSize(testString));
            Assert.Contains("String too long", exception.Message, StringComparison.Ordinal);
            Assert.Equal("value", exception.ParamName);
        }

        [Fact]
        public void WriteString_ReadString_RoundTrip_EmbeddedNull()
        {
            // Arrange: String with embedded NUL characters
            var s = "a\0b\0c";
            var buf = new byte[2 + Encoding.UTF8.GetByteCount(s)];

            // Act - Write
            var written = RnsCodec.WriteString(buf, s);

            // Act - Read
            var read = RnsCodec.ReadString(buf, out var back);

            // Assert
            Assert.Equal(written, read);
            Assert.Equal(s, back);
        }

        [Fact]
        public void GetStringSerializedSize_TooLongMultiByte_Throws()
        {
            // Arrange: Create a string with multi-byte characters that exceeds 65535 bytes
            // Each emoji is 4 bytes in UTF-8, so we need > 16383 emojis to exceed the limit
            var emoji = "😀"; // U+1F600, 4 bytes in UTF-8
            var s = string.Join("", Enumerable.Repeat(emoji, 17000)); // 17000 * 4 = 68000 bytes > 65535

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => RnsCodec.GetStringSerializedSize(s));
            Assert.Contains("String too long", exception.Message, StringComparison.Ordinal);
            Assert.Equal("value", exception.ParamName);
        }

        #endregion
    }
}
